/*ENGENHARIA DE CONTROLE E AUTOMAÇÃO*/
/*SYLVIELLY S SOUSA*/
/*DISPOSITIVOS PERIFERICOS*/
//PROGRAMAS PROF. FABIO
//SEMESTRE 2020.1


//PROJETAR UM CONTROLE PI DE TEMPERATURA

//CONFIGURACOES DE BOTOES
#define POTENCIOMETRO 0x7C08     //B0
#define BOTOES  0x7C09           //B1
#define AUMENTAR 0x7C0A          //B2
#define DIMINUIR 0x7C0B          //B3
#define VOLTAR 0x7C0C          //B4

//CONFIGURACOES PADRAO
#include<18f4550.h>                      //BIBLIOTECA PIC18F4550
#device adc = 10                         //RESOLUCAO DO ADC 10 BITS
#fuses HS, CPUDIV1,PLL5,USBDIV           //HABILITACAO DOS FUSIVEIS
#use delay(clock=20000000)
#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)        //CONFIGURACAO SERIAL

//CONFIGURACOES LCD PICGENIOS
#define LCD_DB0   PIN_D0
#define LCD_DB1   PIN_D1
#define LCD_DB2   PIN_D2
#define LCD_DB3   PIN_D3
#define LCD_DB4   PIN_D4
#define LCD_DB5   PIN_D5
#define LCD_DB6   PIN_D6
#define LCD_DB7   PIN_D7
#define LCD_E     PIN_E1
#define LCD_RS    PIN_E2
#include <flex_lcd.c>                     //BIBLIOTECA LCD PICGENIOS

//DECLARACAO DE VARIAVEIS    
signed long int setpoint_temperatura = 0;       //VALOR DE TEMPERATURA DESEJADO PELO USUARIO
signed long int digital_setpoint = 0;           //ENTRADA EM UNIDADE DE ENGENHARIA
float AD0 = 0;                                  //PORTA ANALOGICA AN0
float AD2 = 0;                                  //PORTA ANALOGICA AN2
signed long int digital_potenciometro = 0;        //VALOR POTENCIOMETRO EM UNIDADE DE ENGENHARIA SAIDA
signed long int digital_temperatura = 0;        //TEMPERATURA EM UNIDADE DE ENGENHARIA SAIDA
signed long int potenciometro_real = 0;
signed long int temperatura_graus_atual = 0;    //TEMPERATURA EM GRAUS PORTA ANALOGICA AN2
signed long int FLAG_BOTOES = 0;                //FLAG MODO DE OPERACAO POR BOTOES [B1]
signed long int FLAG_POTENCIOMETRO = 0;         //FLAG POTENCIOMETRO              
signed long int FLAG_AUMENTAR = 0;              //FLAG BOTAO B2
signed long int FLAG_OPERACAO = 0;              //FLAG MODO DE OPERACAO PARA QUE ESTE ESCOLHA CORRETAMENTE QUANDO O MODO DE OPERACAO B1 OU B0 SEJA SELECIONADO CORRETAMENTE             
signed long int FLAG_DIMINUIR = 0;              //FLAG BOTAO B3
signed long int FLAG_VOLTAR = 0;                //FLAG BOTAO B4
signed long int PWM_CONFIG = 0;                 //CONFIGURACAO PWM
signed long int proporcional = 0;               //PROPORCIONAL
signed long int erro=0;                         //ERRO
signed long int saida_atual=0;                  //SAIDA CONTROLADA
float KP = 0.1;
signed long int integral = 0;                   
float KI=0.091;                                 //CONSTANTE INTEGRADOR
signed long int INTEGRAL_SYS = 0;               //CALCULO INTEGRADOR

//FUNCAO DE CONFIGURACAO DE TEMPERATURA PARA MENU DE OPCOES
void AUMENTAR_TEMPERATURA(){
       if(input(AUMENTAR)==0){
         FLAG_AUMENTAR = 1;                       
         }
         while((FLAG_AUMENTAR==1)&&(input(AUMENTAR)==1)){
               setpoint_temperatura+=1;
               lcd_gotoxy(1,1);
               printf("\f\r\n");
               printf(lcd_putc,"\fSETPOINT: %li\r\n",setpoint_temperatura);
               delay_ms(1000);
               FLAG_AUMENTAR = 0;
               }
}

void DIMINUIR_TEMPERATURA(){
       if(input(DIMINUIR)==0){
         FLAG_DIMINUIR = 1;                       
         }
         while((FLAG_DIMINUIR==1)&&(input(DIMINUIR)==1)){
               setpoint_temperatura-=1;
               lcd_gotoxy(1,1);
               printf("\f\r\n");
               printf(lcd_putc,"\fSETPOINT: %li\r\n",setpoint_temperatura);
               delay_ms(1000);
               FLAG_DIMINUIR = 0;
               }
}

//FUNCAO COM CONFIGURACOES E O CONTROLADOR PI
void PID(){
     if(digital_temperatura>0){     
                  erro = digital_setpoint - digital_temperatura;         //CALCULO DO ERRO [ENTRADA - SAIDA]
                  proporcional = KP*erro;                                //CALCULO PROPORCIONAL, COM KP = 0.1
                  integral = (integral + erro);                      
                  INTEGRAL_SYS = (integral*KI);                         //CALCULO INTEGRAL, COM KI = 0.091
            if (INTEGRAL_SYS>920.7){
                  INTEGRAL_SYS = 920.7;                                 //LIMITES DO GANHO DO INTEGRADOR
            if((setpoint_temperatura==0)&&(digital_temperatura==0)){    //CONDICAO CASO ENTRADA SEJA ZERO, SAIDA PERMANECER ZERO
               saida_atual = 0;
           }
           }
           }
}

//INICIO FUNCAO DE TEMPO
#int_timer0
void funcao_tempo(){
      static unsigned int32 n;
      set_timer0(131+get_timer0());
      n++;
   if (setpoint_temperatura > 150){                 //LIMITES DE SETPOINT DE TEMPERATURA
         setpoint_temperatura = 150;
         }
   digital_setpoint = setpoint_temperatura*6.82;    //CONVERSAO TEMPERATURA EM UNIDADE DE ENGENHARIA PARA EFETUAR OS CALCULOS DO CONTROLE
      if (n==100){ 
            n=0;
            PID();
            }            
}

//FIM FUNCAO DE TEMPO

void main(){  
      
      lcd_init();                    //INICIALIZACAO LCD
      port_b_pullups(true);          //HABILITACAO DOS PULLUPS PARA BOTOES DA PLACA

      //CONFIGURACAO TIMER0 PARA EXECUCAO DO CONTROLADOR
         setup_timer_0 (RTCC_DIV_64|RTCC_INTERNAL | RTCC_8_BIT );
         set_timer0(131);
      
      //INICIO CONFIGURACAO DAS PORTAS ANALOGICAS
         setup_adc_ports(AN0_TO_AN2);
         setup_adc(adc_clock_internal);         //PINO AN0 E AN2 SERAO OS OS PINOS DE DETECCAO DE POTENCIOMETRO E TEMPERATURA RESPECTIVAMENTE 
         set_adc_channel(0);
         set_adc_channel(2);
      //FIM CONFIGURACAO DAS PORTAS ANALOGICAS
      
      //INICIO HABILITACOES INTERRUPCOES
         enable_interrupts(global);
         enable_interrupts(INT_TIMER0);
      //FIM HABILITACOES INTERRUPCOES
  
      setup_timer_2(T2_DIV_BY_4, 249, 1);          //PREPARACAO CONFIGURACAO DE PR2 PARA OS PINOS DE PWM [CCP2]
      
                        lcd_gotoxy(1,1);
                        printf("\f\r\n");
                        printf(lcd_putc,"\fCONTROLE DE TEMP\r\n");
                        lcd_gotoxy(1,2);
                        printf(lcd_putc,"BY SYLVIELLY\r\n");
                        delay_ms(2000);
                        lcd_gotoxy(1,1);
                        printf("\f\r\n");
                        printf(lcd_putc,"\fB1:BOTOES\r\n");
                        lcd_gotoxy(1,2);
                        printf(lcd_putc,"B0:POTENCIOMETRO\r\n");       
                              
   while(true){
            FLAG_OPERACAO+=1;       //CONTADOR PARA O MODO DE OPERACAO. CASO SEJA '1', VAI PARA CONDICIONAL DE BOTOES. CASO SEJA     
            //CONDICIONAL PARA MODO DE OPERACAO DO SETPOINT
            //B1: OPERACAO POR BOTOES | B0: OPERACAO POR POTENCIOMETRO
            if((input(BOTOES)==0)&&(input(POTENCIOMETRO)==1)&&(FLAG_OPERACAO==1)){          
                  FLAG_BOTOES = 1;                                      
                  }
                  //SE MODO DE OPERACAO FOR POR MEIO DE BOTOES [B1], PASSA PARA A PROXIMA CONDICAO
                  if((FLAG_BOTOES==1)&&(input(BOTOES)==1)&&(FLAG_OPERACAO==1)){
                        lcd_gotoxy(1,1);
                        printf("\f\r\n");
                        printf(lcd_putc,"\fB2:AUMENTAR\r\n");
                        lcd_gotoxy(1,2);
                        printf(lcd_putc,"B3:DIMINUIR\r\n");
                        delay_ms(1000);
                        }
                        AUMENTAR_TEMPERATURA();
                        DIMINUIR_TEMPERATURA();
         
            //SE MODO DE OPERACAO FOR POR MEIO DE POTENCIOMETRO [B0], EFETUA LEITURA DA PORTA ANALOGICA
            //INICIO DE LEITURA DE TEMPERATURA DA PORTA ANALOGICA
            if((input(POTENCIOMETRO)==0)&&(input(BOTOES)==1)&&(FLAG_OPERACAO==2)&&(FLAG_BOTOES==0)){          
                  FLAG_POTENCIOMETRO = 1;                                      
               while(FLAG_POTENCIOMETRO==1){
                  AD0 = read_adc();
                  delay_us(100);
                  digital_potenciometro = AD0;                      //CONVERSAO DA UNIDADE DE ENGENHARIA LIDA EM AD2 PARA TEMPERATURA
                  potenciometro_real = digital_potenciometro*0.0048875855327468;
                  lcd_gotoxy(1,1);
                  printf("\f\r\n");
                  printf(lcd_putc,"\fSETPOINT: %li\r\n",potenciometro_real);
                  delay_ms(1000);
                  FLAG_POTENCIOMETRO = 0;
                  }
                }
           //RETORNAR AO MENU PRINCIPAL
           if((input(VOLTAR)==0)&&(input(BOTOES)==1)&&(input(POTENCIOMETRO)==1)){
                     FLAG_VOLTAR = 1;
                     if(FLAG_VOLTAR==1){
                        FLAG_BOTOES = 0;
                        FLAG_POTENCIOMETRO = 0;
                        FLAG_VOLTAR = 0;
                        }
                     }
                  //CONDICOES CASO FLAG DE OPERACAO SEJA MAIOR QUE '2'   
                  if(FLAG_OPERACAO>2){
                     FLAG_OPERACAO = 0;
                     }
                  
               
               //INICIO DE LEITURA DE TEMPERATURA DA PORTA ANALOGICA
               AD2 = read_adc();
               delay_us(100);
               digital_temperatura = AD2;                      //CONVERSAO DA UNIDADE DE ENGENHARIA LIDA EM AD2 PARA TEMPERATURA
               
               
               //SAIDA ATUAL DO CONTROLADOR
               saida_atual = proporcional+INTEGRAL_SYS; 
               temperatura_graus_atual = digital_temperatura*0.488758;
                        
               //PWM CONFIGURACOES PARA ACIONAMENTO
               PWM_CONFIG = (saida_atual*0.2443792766);               
                   if(PWM_CONFIG>=250){
                      PWM_CONFIG = 250;
                      }
                   if(PWM_CONFIG<0){
                      PWM_CONFIG = 0;
                      }
               set_pwm2_duty(PWM_CONFIG);             //CONFIGURA RAZAO CICLICA [DUTY CYCLE = Ton / Ton+Toff]
               setup_ccp2(CCP_PWM);                   //ENVIA VALOR DO PWM CONFIGURADO PARA A PORTA CCP2                        
   }
}

