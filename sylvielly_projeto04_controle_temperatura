/*ENGENHARIA DE CONTROLE E AUTOMAÇÃO*/
/*SYLVIELLY S SOUSA*/
/*DISPOSITIVOS PERIFERICOS*/
//PROGRAMAS PROF. FABIO
//SEMESTRE 2020.1

//CONFIGURACOES DE BOTOES
#define B1        0x7C09            //B1 [ENTRA NA OPCAO BOTOES]
#define AQUECEDOR 0x7C15            //C5 [SAIDA DIGITAL MICRO - ENTRADA DIGITAL PLANTA]

//CONFIGURACOES PADRAO
#include<18f4550.h>                      //BIBLIOTECA PIC18F4550
#device adc = 10                         //RESOLUCAO DO ADC 10 BITS
#fuses HS, CPUDIV1,PLL5,USBDIV           //HABILITACAO DOS FUSIVEIS
#use delay(clock=20000000)
#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)        //CONFIGURACAO SERIAL

//CONFIGURACOES LCD PICGENIOS
#define LCD_DB0   PIN_D0
#define LCD_DB1   PIN_D1
#define LCD_DB2   PIN_D2
#define LCD_DB3   PIN_D3
#define LCD_DB4   PIN_D4
#define LCD_DB5   PIN_D5
#define LCD_DB6   PIN_D6
#define LCD_DB7   PIN_D7
#define LCD_E     PIN_E1
#define LCD_RS    PIN_E2
#include <flex_lcd.c>                     //BIBLIOTECA LCD PICGENIOS
#priority rda

//DECLARACAO DE VARIAVEIS    
unsigned int32 AD0;
unsigned int32 AD1;
int FLAG_B1 = 0;
int HEATER_BYTE_1;
int HEATER_BYTE_2;
int IN_VALVE_BYTE_1;
int IN_VALVE_BYTE_2;
int ALERTA_TEMP_MAX = 0x13;
int VOLUME_BYTE_1;
int TEMPERATURA_BYTE_1;
int16 VALOR_H;
int16 VALOR_L;
int16 TEMP_H;
int16 TEMP_L;
int16 TEMP_MAX = 80;

void PARADA(){
     putc(0x00);
     putc(0x00);
}
//FUNCOES DO SERIAL REMOTE TANK
void LIGA_AQUECEDOR(){
     HEATER_BYTE_1 = 0x02;
     HEATER_BYTE_2 = 0x01;
     putc(HEATER_BYTE_1);
     putc(HEATER_BYTE_2);
}

void LIGA_VALVULA_ENTRADA(){
     IN_VALVE_BYTE_1 = 0x00;
     IN_VALVE_BYTE_2 = 0x01;
     putc(IN_VALVE_BYTE_1);
     putc(IN_VALVE_BYTE_2);     
}

void DESLIGA_AQUECEDOR(){
     HEATER_BYTE_1 = 0x02;
     HEATER_BYTE_2 = 0x00;
     putc(HEATER_BYTE_1);
     putc(HEATER_BYTE_2);
     putc(ALERTA_TEMP_MAX);
}

void DESLIGA_VALVULA_ENTRADA(){
     IN_VALVE_BYTE_1 = 0x01;
     IN_VALVE_BYTE_2 = 0x00;
     putc(IN_VALVE_BYTE_1);
     putc(IN_VALVE_BYTE_2);
     
}

void LEITURA_VOLUME(){
     VOLUME_BYTE_1 = 0x30;
     putc(VOLUME_BYTE_1);
}

void LEITURA_TEMPERATURA(){
     TEMPERATURA_BYTE_1 = 0x31;
     putc(TEMPERATURA_BYTE_1);
}
//INTERRUPCAO DA SERIAL [FUNCIONANDO]
#int_rda
void INTERRUPCAO_SERIAL(){
         VALOR_H = getc();
         VALOR_L = getc();
         AD0 = ((VALOR_H<<8)|(VALOR_L))*0.0333333333333333333333333333333333333;       //LEITURA VOLUME DO TANQUE ATRAVES DE PORCENTAGEM
         
         TEMP_H = getc();
         TEMP_L = getc();
         AD1  = ((TEMP_H<<8)|(TEMP_L))*1;
}
void main(){
      
      lcd_init();                    //INICIALIZACAO LCD
      port_b_pullups(true);          //HABILITACAO DOS PULLUPS PARA BOTOES DA PLACA

      //inicio habilitacao interrupcoes
         enable_interrupts(global);
         enable_interrupts(int_rda);            //interrupcao para serial
         
         LIGA_VALVULA_ENTRADA();
         delay_ms(100);
         DESLIGA_VALVULA_ENTRADA();
         delay_ms(5000);
         PARADA();
 
   while(true){
      if(input(B1)==0){
         FLAG_B1 = !FLAG_B1;
         }
         if(FLAG_B1 == 1){
            do{
              LIGA_AQUECEDOR();
              LEITURA_VOLUME();
              LEITURA_TEMPERATURA();
              lcd_gotoxy(1,1);
              printf(lcd_putc,"\fVOLUME: %lu \r\n",AD0);
              lcd_gotoxy(1,2);
              printf(lcd_putc,"TEMP: %lu \r\n",AD1);
              delay_ms(50);
             }while((AD1>0)&&(AD1<TEMP_MAX));
                  if(AD1>=TEMP_MAX){
                     DESLIGA_AQUECEDOR();
                     PARADA();
                     FLAG_B1 = 0;
                     lcd_gotoxy(1,1);
                     printf(lcd_putc,"\fVOLUME: %lu \r\n",AD0);
                     lcd_gotoxy(1,2);
                     printf(lcd_putc,"TEMP: %lu \r\n",AD1);
                     delay_ms(50);
                     }
            }
   }
}
